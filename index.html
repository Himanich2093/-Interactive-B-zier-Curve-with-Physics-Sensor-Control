<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>Bezier Rope â€” Interactive</title>
  <style>
    html,body { margin:0; padding:0; height:100%; background:#0b0f12; color:#fff; }
    canvas { display:block; width:100vw; height:100vh; }
    .hint {
      position: fixed; left: 12px; top: 12px;
      background: rgba(0,0,0,0.35); padding:8px 12px; border-radius:8px;
      font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
      font-size:13px; color:#ddd;
      backdrop-filter: blur(6px);
    }
  </style>
</head>
<body>
  <div class="hint">Drag to pull. On mobile, tilt (device orientation) will move control points.</div>
  <canvas id="c"></canvas>
<script>
/* -------------------------
   Math utilities
   ------------------------- */
function vec(x = 0, y = 0){ return { x: x, y: y }; }
function add(a,b){ return { x: a.x + b.x, y: a.y + b.y }; }
function sub(a,b){ return { x: a.x - b.x, y: a.y - b.y }; }
function mul(a,s){ return { x: a.x * s, y: a.y * s }; }
function len(a){ return Math.hypot(a.x, a.y); }
function norm(a){ const L = len(a) || 1; return { x: a.x / L, y: a.y / L }; }

/* Cubic Bezier point B(t) */
function bezierPoint(t, P0, P1, P2, P3){
  const u = 1 - t;
  const tt = t * t;
  const uu = u * u;
  const uuu = uu * u;
  const ttt = tt * t;

  let p = mul(P0, uuu);
  p = add(p, mul(P1, 3 * uu * t));
  p = add(p, mul(P2, 3 * u * tt));
  p = add(p, mul(P3, ttt));
  return p;
}

/* Cubic Bezier derivative B'(t) */
function bezierTangent(t, P0, P1, P2, P3){
  const u = 1 - t;
  const tt = t * t;
  const uu = u * u;

  const term1 = mul(sub(P1, P0), 3 * uu);
  const term2 = mul(sub(P2, P1), 6 * u * t);
  const term3 = mul(sub(P3, P2), 3 * tt);
  return add(add(term1, term2), term3);
}

/* -------------------------
   Canvas & Setup
   ------------------------- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

function resize(){
  // make canvas high-DPI aware
  const dpr = Math.max(window.devicePixelRatio || 1, 1);
  canvas.width = Math.floor(window.innerWidth * dpr);
  canvas.height = Math.floor(window.innerHeight * dpr);
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', resize);
resize();

/* -------------------------
   Spring state for control points
   ------------------------- */
function makeSpringState(initialPos){
  return {
    pos: vec(initialPos.x, initialPos.y),
    vel: vec(0,0),
    target: vec(initialPos.x, initialPos.y)
  };
}

const SPRING_K = 60;    // stiffness
const SPRING_D = 12;    // damping (tweak for more/less damping)

/* initial endpoints and springs */
let P0 = vec(canvas.width * 0.1 / (window.devicePixelRatio||1), canvas.height * 0.5 / (window.devicePixelRatio||1));
let P3 = vec(canvas.width * 0.9 / (window.devicePixelRatio||1), canvas.height * 0.5 / (window.devicePixelRatio||1));
let spring1 = makeSpringState(vec(window.innerWidth * 0.3, window.innerHeight * 0.35));
let spring2 = makeSpringState(vec(window.innerWidth * 0.7, window.innerHeight * 0.65));

/* -------------------------
   Input: mouse & touch & deviceorientation
   ------------------------- */
let mouse = vec(window.innerWidth/2, window.innerHeight/2);
let isDragging = false;

function clientToCanvas(evX, evY){
  // return coordinates in CSS pixels
  return vec(evX, evY);
}

canvas.addEventListener('pointerdown', (e) => {
  isDragging = true;
  const p = clientToCanvas(e.clientX, e.clientY);
  mouse = p;
  e.preventDefault();
});
window.addEventListener('pointermove', (e) => {
  if (!isDragging) return;
  mouse = clientToCanvas(e.clientX, e.clientY);
});
window.addEventListener('pointerup', (e) => { isDragging = false; });

canvas.addEventListener('touchstart', (e) => {
  isDragging = true;
  const t = e.touches[0];
  mouse = clientToCanvas(t.clientX, t.clientY);
}, {passive:false});
canvas.addEventListener('touchmove', (e) => {
  if (!isDragging) return;
  const t = e.touches[0];
  mouse = clientToCanvas(t.clientX, t.clientY);
}, {passive:false});
canvas.addEventListener('touchend', (e) => { isDragging = false; });

/* Device orientation as optional gyro input */
if (window.DeviceOrientationEvent) {
  window.addEventListener('deviceorientation', (ev) => {
    // ev.beta: front-back tilt (-180 to 180), ev.gamma: left-right (-90 to 90)
    const pitch = ev.beta || 0;
    const roll  = ev.gamma || 0;
    const factor = Math.max(window.innerHeight, window.innerWidth) * 0.01;
    const baseY = window.innerHeight * 0.5;

    // drive vertical targets; keep X at fractions between endpoints
    spring1.target.y = baseY + pitch * factor;
    spring2.target.y = baseY + roll  * factor;
    spring1.target.x = window.innerWidth * 0.3;
    spring2.target.x = window.innerWidth * 0.7;
  }, { passive: true });
}

/* -------------------------
   Physics: semi-implicit Euler spring step
   ------------------------- */
function stepSpring(state, dt){
  const displacement = sub(state.pos, state.target); // x - xtarget
  // acceleration = -k * displacement - c * velocity
  const acc = sub(mul(displacement, -SPRING_K), mul(state.vel, SPRING_D));
  state.vel = add(state.vel, mul(acc, dt));
  state.pos = add(state.pos, mul(state.vel, dt));
}

/* -------------------------
   Update targets mapping
   ------------------------- */
function updateTargets(){
  // keep endpoints fixed horizontally at 10% and 90% of width
  P0 = vec(window.innerWidth * 0.1, window.innerHeight * 0.5);
  P3 = vec(window.innerWidth * 0.9, window.innerHeight * 0.5);

  // If dragging, make the mouse influence both control targets
  if (isDragging) {
    // P1 is closer to P0, P2 closer to P3. Map mouse Y into influence.
    const midY = window.innerHeight * 0.5;
    const deltaY = mouse.y - midY;
    spring1.target.x = P0.x + (P3.x - P0.x) * 0.3;
    spring2.target.x = P0.x + (P3.x - P0.x) * 0.7;
    spring1.target.y = midY + deltaY * 0.9; // slightly amplify
    spring2.target.y = midY + deltaY * 0.6; // different sensitivity for variety
  } else {
    // Relax to baseline positions (horizontal band)
    spring1.target = vec(P0.x + (P3.x - P0.x) * 0.3, window.innerHeight * 0.35);
    spring2.target = vec(P0.x + (P3.x - P0.x) * 0.7, window.innerHeight * 0.65);
  }
}

/* -------------------------
   Rendering helpers
   ------------------------- */
function drawPoint(p, color = '#ffaa00', r = 6){
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
  ctx.fill();
}

/* Draw tangents at intervals */
function drawTangents(P0_, P1_, P2_, P3_){
  ctx.strokeStyle = '#3ce6b7';
  ctx.lineWidth = 1;
  const tangentLength = Math.min(window.innerWidth, window.innerHeight) * 0.06;
  for (let t=0; t<=1.0001; t += 0.1){
    const p = bezierPoint(t, P0_, P1_, P2_, P3_);
    const tan = bezierTangent(t, P0_, P1_, P2_, P3_);
    const n = norm(tan);
    const p2 = add(p, mul(n, tangentLength));
    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();
  }
}

/* -------------------------
   Main animation loop
   ------------------------- */
let lastTime = performance.now();

function frame(now){
  const dt = Math.min((now - lastTime) / 1000, 0.033);
  lastTime = now;

  updateTargets();
  stepSpring(spring1, dt);
  stepSpring(spring2, dt);

  const P1 = spring1.pos;
  const P2 = spring2.pos;

  // Clear
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Background
  ctx.fillStyle = '#0b0f12';
  ctx.fillRect(0,0, window.innerWidth, window.innerHeight);

  // Draw control polygon
  ctx.lineWidth = 1;
  ctx.strokeStyle = '#2e3440';
  ctx.beginPath();
  ctx.moveTo(P0.x, P0.y);
  ctx.lineTo(P1.x, P1.y);
  ctx.lineTo(P2.x, P2.y);
  ctx.lineTo(P3.x, P3.y);
  ctx.stroke();

  // Draw Bezier as sampled polyline
  ctx.lineWidth = 3;
  ctx.strokeStyle = '#00d4ff';
  ctx.beginPath();
  const step = 0.01;
  for (let t = 0; t <= 1.0001; t += step) {
    const p = bezierPoint(t, P0, P1, P2, P3);
    if (t === 0) ctx.moveTo(p.x, p.y);
    else ctx.lineTo(p.x, p.y);
  }
  ctx.stroke();

  // Draw thin "shadow" for depth
  ctx.lineWidth = 6;
  ctx.strokeStyle = 'rgba(0,0,0,0.18)';
  ctx.beginPath();
  for (let t = 0; t <= 1.0001; t += step) {
    const p = bezierPoint(t, P0, P1, P2, P3);
    if (t === 0) ctx.moveTo(p.x + 2, p.y + 3);
    else ctx.lineTo(p.x + 2, p.y + 3);
  }
  ctx.stroke();

  // Draw tangents
  drawTangents(P0, P1, P2, P3);

  // Draw control points
  drawPoint(P0, '#ff6b6b', 6);
  drawPoint(P1, '#ffaa00', 6);
  drawPoint(P2, '#ffaa00', 6);
  drawPoint(P3, '#ff6b6b', 6);

  // draw small label when dragging
  if (isDragging) {
    ctx.fillStyle = 'rgba(255,255,255,0.88)';
    ctx.font = '12px system-ui, -apple-system, Roboto, "Segoe UI", sans-serif';
    ctx.fillText('dragging', mouse.x + 12, mouse.y - 10);
  }

  requestAnimationFrame(frame);
}

/* initialize and start */
requestAnimationFrame(frame);

/* expose a resize-friendly re-init */
window.addEventListener('resize', () => {
  resize();
  // reset endpoints / spring targets to fit new size
  spring1.target = vec(window.innerWidth * 0.3, window.innerHeight * 0.35);
  spring2.target = vec(window.innerWidth * 0.7, window.innerHeight * 0.65);
});
</script>
</body>
</html>
